import os
from linkedin.neelix.metric import Metric
import linkedin.neelix.metric
from linkedin import ingraphs
import datetime

class IngraphsMetric(Metric):
  """ Class for Ingraphs rrds, deriving from class Metric """
  calc_metrics = None
  def __init__(self, metric_type, infile, inaccess, outdir, label, ts_start, ts_end, type, type_val, consolidate, resolution):
    Metric.__init__(self, metric_type, infile, inaccess, outdir, label, ts_start, ts_end)
    self.type = type
    self.type_val = type_val
    self.resolution = resolution
    self.consolidate = consolidate
    self.csvfiles = []

  def collect(self):
    """Fetch data from ingraphs and also parse to split out csvs """
    if self.inaccess != 'ingraphs':
      print "Incorrect access", self.access, "set for Ingraphs metric. Cannot process this metric further"
      return False
    client = ingraphs.IngraphsClient()
    out_csv = self.get_csv()
    ingraphs_type = self.type
    #determine which type of data retrieval function to call
    if ingraphs_type == 'service':
      data_retrieval_func = client.service_data
    elif ingraphs_type == 'host':
      data_retrieval_func = client.host_data
    elif ingraphs_type == 'tag':
      data_retrieval_func = client.tag_data
    else:
      print "ingraphs type can be either service, tag or host. Given:", ingraphs_type
      return False
    #retrieve data and append into form high charts can understand
    rrd = self.infile
    ingraphs_response = data_retrieval_func(self.type_val, rrd, start=self.ts_start, end=self.ts_end, consolidate=self.consolidate, resolution=self.resolution)
    # Assuming only one timeseries returned
    if self.consolidate:
      data = ingraphs_response['data'][self.consolidate]
    else:
      data = ingraphs_response['data'][self.type_val]
    with open(out_csv, 'w') as FH:
      self.csvfiles.append(out_csv)
      for ts in sorted(data):
        dt = datetime.datetime.fromtimestamp(float(ts))
        ts_string = dt.strftime("%Y-%m-%d %H:%M:%S.%f")
        FH.write(ts_string)
        FH.write(',')
        if data[ts] == "None":
          FH.write()
        else:
          FH.write(str(data[ts]))
        FH.write('\n')
    return True

  def graph(self, perfrepo):
    html_string = ["<h1>Metric: %s</h1>\n" % (self.metric_type)]
    for out_csv in self.csvfiles:
      csv_filename = os.path.basename(out_csv)
      # The last element is .csv, don't need that in the name of the chart
      x = '.'.join(csv_filename.split('.')[0:-1])
      linkedin.neelix.metric.graph_csv(perfrepo, self.outdir, out_csv, x, x)
      imgtag = "<h3>%s</h3><img src=%s />\n" % (x, x+'.png')
      html_string.append(imgtag)
    return '\n'.join(html_string)

  def get_csv(self):
    out_csv = os.path.join(self.outdir, "{0}.csv".format(self.metric_type))
    return out_csv

  def parse(self):
    return True

