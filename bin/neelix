#!/usr/bin/env python
"""Neelix is a command line tool for parsing and visually correlating different metrics. For details, please read wiki: http://go/neelix"""

import argparse
import ConfigParser
import datetime
import errno
import os
import re
import sys
import threading
import time

# Add src directory to path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'src')))

import neelix.metric
from neelix.metric import Metric
from neelix.gc_metric import GCMetric
from neelix.innotop_metric import INNOMetric
from neelix.sar_metric import SARMetric
from neelix.graphing import dygraphs


try:
  from neelix.neelix_imports import metric_classes, graphing_modules
except ImportError:
  metric_classes = {}
  graphing_modules = {}

#Neelix pre-defined
metric_classes['GC'] = GCMetric
metric_classes['SAR'] = SARMetric
metric_classes['INNOTOP'] = INNOMetric

graphing_modules['dygraphs'] = dygraphs
graphing_modules['js'] = dygraphs
graphing_modules['javascript'] = dygraphs

version = "0.9"

template_urls = {
    "template:gc": "http://svn.corp.linkedin.com/perfrepo/trunk/perfcode/neelix/templates/config-gc",
    "template:sar": "http://svn.corp.linkedin.com/perfrepo/trunk/perfcode/neelix/templates/config-sar",
    "template:innotop": "http://svn.corp.linkedin.com/perfrepo/trunk/perfcode/neelix/templates/config-inno"
    }

def read_neelix_templates():
  """
    Read $HOME/.neelix/templates.txt file to read user-defined template keys and related URLs
  """
  home_directory = os.getenv('HOME')
  template_file = os.path.join(home_directory, '.neelix', 'templates.txt')
  print 'INFO: Adding templates from: ' + template_file
  if os.path.exists(template_file):
    with open(template_file,'r') as FH:
      for line in FH:
        template, url = [word.strip() for word in line.split()]
        if neelix.metric.is_valid_url(url):
          print 'ERROR: This line in .neelix/templates.txt does not contain correct URL.' + line + '. Continuing.'
          continue
        if not template.startswith('template:'):
          print 'ERROR: Template name in this line in .neelix/templates.txt does not follow the convention. Start the name with "template:" please.'
          continue
        if template in template_urls:
          print 'INFO: Template ' + template + ' exists as pre-defined in Neelix. Overriding the pre-defined template name.'
        print 'INFO: Adding template ' + template
        template_urls[template] = url

def parse_and_plot_single_metrics(metric, graph_timezone, outdir_default, indir_default, metric_string_list, graphing_library):
  metric.graph_timezone = graph_timezone
  if metric.outdir is None:
    metric.outdir = os.path.normpath(outdir_default)
  if not indir_default is None:
    metric.infile = os.path.join(indir_default, metric.infile)
  if not metric.ignore:
    if metric.collect():
      if metric.parse():
        metric.calc()
        metric_html_string = metric.graph(graphing_library)
        metric_string_list.append(metric_html_string)
      else:
        print 'Parsing failed for metric: ', metric.label
    else:
      print 'Fetch/Collect failed for metric: ', metric.label

def transform_ts(start, end, timezone="PDT"):
  """
    Transform ingraphs-like time specification to real datetime string.
    Neelix will assume everything is in PDT unless log is being fetched from production, in which case it will be UTC

    :param string start: start timestamp in format YYYY-mm-DD HH:MM:SS or 'end-X((days|day|hours|hour)'
    :param string end: end timestamp in format YYYY-mm-DD HH:MM:SS or 'now'
    :param string timezone: timezone to transform the timestamps into. Should be one of these: (UTC, PST, PDT)
    :return: A tuple of start timestamp and end timestamps transformed from inGraphs like specification to YYYY-mm-DD HH:MM:SS formats
  """
  ts_pattern = "\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}"
  #If timestamp is not in YYYY-mm-DD HH:MM:SS format, then it must be in inGraphs format
  if not re.match(ts_pattern, end):
    if end == "now":
      if timezone in ("PDT", "PST"):
        end_ts = datetime.datetime.now()
      else:
        end_ts = datetime.datetime.utcnow()
      end_ts_str = datetime.datetime.strftime(end_ts, "%Y-%m-%d %H:%M:%S")
    else:
      sys.exit("End timestamp supported with only YYYY-mm-DD HH:MM:SS or 'now' formats. Please fix config. Exiting...")
  else:
    end_ts_str = end
    end_ts = datetime.datetime.strptime(end, "%Y-%m-%d %H:%M:%S")
  if start and not re.match(ts_pattern, start):
    reg_match = re.match("end-(\d+)(days|day|hours|hour)", start)
    if reg_match:
      key = reg_match.group(2)
      val = int(reg_match.group(1))
      if "day" in key:
        delta = datetime.timedelta(days=val)
      elif "hour" in key:
        delta = datetime.timedelta(hours=val)
      start_ts = end_ts - delta
      start_ts_str = datetime.datetime.strftime(start_ts, "%Y-%m-%d %H:%M:%S")
    else:
      #TODO(rmaheshw): Add support for minutes and chaining like end-1day2hours5minutes
      sys.exit("Start timestamp supported with only YYYY-mm-DD HH:MM:SS or 'end-x(days|day|hours|hour)' formats. Please fix config. Exiting...")
  else:
    start_ts_str = start
  return (start_ts_str, end_ts_str)

def main():
  metrics = []
  crossplots = []
  filler = '-999' # Using Wai's filler value for graph skipping. At some point we should use something more standard, may be put nothing TODO
  graph_timezone = None
  graphing_library = 'js'
  variables_dict = {}
  bin_path = os.path.dirname( __file__ )

  arg_parser = argparse.ArgumentParser()

  arg_parser.add_argument('config', help="file with specifications for each metric and graphs")
  arg_parser.add_argument('-i', '--input_dir', help="input directory used to construct full path name of the metric infile")
  arg_parser.add_argument('-o', '--output_dir', help="output directory where the plots and Report.html will be generated")
  arg_parser.add_argument('-k', '--sshkey_location', help="full path to your ssh key (for fetching files from remote hosts)")
  arg_parser.add_argument('-p', '--passphrase', help="your ssh key passphrase")
  arg_parser.add_argument('-host', '--hostname', help="Default remote host for downloading logs from. hostname specified in config takes precedence over this")
  arg_parser.add_argument('-V', '--variables', action="append", help="User defined variables (in form key=value) for substitution in the config file. Config should have the variable names in format %%(key)s")
  arg_parser.add_argument('-s', '--show_config', help="Print config associated with the provided template name", action="store_true")
  #TODO(rmaheshw) : Print a list of all templates supported with descriptions
  #arg_parser.add_argument('-l', '--list_templates', help="List all template configs", action="store_true")

  args = arg_parser.parse_args()

  if args:
    read_neelix_templates()
    # Print template config
    if args.show_config:
      tmp_file = neelix.metric.download_file(template_urls[args.config])
      with open(tmp_file, 'r') as FH:
        print "----"
        print FH.read()
      sys.exit("----")

    # Download config if its a URL
    if neelix.metric.is_valid_url(args.config):
      optfile = neelix.metric.download_file(args.config)
    elif args.config.startswith("template:"):
      #Its a template
      if args.config in template_urls.keys():
        print "INFO: Using template " + args.config
        optfile = neelix.metric.download_file(template_urls[args.config])
      else:
        sys.exit("ERROR: Template " + args.config + " not found. Exiting...")
      with open(optfile, 'r') as FH:
        print "Config file used looks like this:"
        print "-------------"
        print FH.read()
        print "-------------"
    else:
      optfile = args.config

    indir_default = args.input_dir
    outdir_default = args.output_dir
    ssh_key_location = args.sshkey_location
    passphrase = args.passphrase
    hostname = args.hostname
    #user defined variables in form "key=value"
    if args.variables:
      for var in args.variables:
        words = var.split('=')
        variables_dict[words[0]] = words[1]

    if not os.path.exists(optfile):
      sys.exit("ERROR: Config file " + optfile + " doesn't exist. If this is a URL, please use the fully qualified domain name (E.g., rmaheshw-ld.linkedin.biz instead of rmaheshw-ld)\nExiting....")

    # Parse the config file
    # TODO: Refactor the config parsing code
    config_obj = ConfigParser.ConfigParser(variables_dict)
    config_obj.read(optfile)
    for section in config_obj.sections():
      if section == 'GRAPH':
        if config_obj.has_option(section, 'graphing_library'):
          graphing_library = config_obj.get(section, 'graphing_library')
        if config_obj.has_option(section, 'graphs'):
          graphs_string = config_obj.get(section, 'graphs')
          crossplots = graphs_string.split()
        # Supporting both outdir and output_dir
        if config_obj.has_option(section, 'outdir'):
          outdir_default = config_obj.get(section, 'outdir')
          #print "in config outdir_default", outdir_default
        if config_obj.has_option(section, 'output_dir'):
          outdir_default = config_obj.get(section, 'output_dir')
        if config_obj.has_option(section, 'input_dir'):
          indir_default = config_obj.get(section, 'input_dir')
        if config_obj.has_option(section, 'graph_timezone'):
          graph_timezone = config_obj.get(section, 'graph_timezone')
          if graph_timezone not in ("UTC", "PST", "PDT"):
            print "Unsupported timezone", graph_timezone, "specified in option graph_timezone"
            print "Will use UTC instead"
            graph_timezone = "UTC"
      else:
        # Metric sections
        access = 'local'
        ts_start = None
        ts_end = "now"
        precision = None
        try:
          infile = config_obj.get(section, 'infile')
          config_obj.remove_option(section, 'infile')
          label = section
          if config_obj.has_option(section, 'access'):
            access = config_obj.get(section, 'access')
            config_obj.remove_option(section, 'access')
            if access == 'ssh':
              if config_obj.has_option(section, 'hostname'):
                hostname = config_obj.get(section, 'hostname')
              else:
                sys.exit('ERROR: specify hostname if access is ssh for metric ' + section)
          if config_obj.has_option(section, 'ts_start'):
            ts_start = config_obj.get(section, 'ts_start')
            config_obj.remove_option(section, 'ts_start')
          if config_obj.has_option(section, 'ts_end'):
            ts_end = config_obj.get(section, 'ts_end')
            config_obj.remove_option(section, 'ts_end')
          if config_obj.has_option(section, 'precision'):
            precision = config_obj.get(section, 'precision')
            config_obj.remove_option(section, 'precision')
          kwargs = dict(config_obj.items(section))
        except:
          print "Exception: " , sys.exc_info()[0], "; Something wrong with the format of the config file in section:", section
          sys.exit(0)
        if section == 'SAR-*':
          sar_metrics = neelix.metric.get_all_sar_objects(metrics, infile, access, outdir_default, label, ts_start, ts_end, None)
          if config_obj.has_option(section, 'ignore') and config_obj.getint(section, 'ignore') == 1:
            for metric in sar_metrics:
              metric.ignore = True
          metrics.extend(sar_metrics)
        else:
          #TODO: Make user specify metric_type in config and not infer from section
          metric_type = section.split('-')[0]
          if not metric_type in metric_classes:
            new_metric = Metric(section, infile, access, outdir_default, label, ts_start, ts_end, **kwargs)
          else:
            new_metric = metric_classes[metric_type](section, infile, access, outdir_default, label, ts_start, ts_end, **kwargs)
          if config_obj.has_option(section, 'ignore') and config_obj.getint(section, 'ignore') == 1:
            new_metric.ignore = True
          if config_obj.has_option(section, 'calc_metrics'):
            new_metric.calc_metrics = config_obj.get(section, 'calc_metrics')
          if access == "ssh":
            new_metric.hostname = hostname
            new_metric.ssh_key_location = ssh_key_location
            new_metric.passphrase = passphrase
          new_metric.bin_path = bin_path
          new_metric.precision = precision
          #Transforming inGraphs style timestamp specification
          if 'INGRAPHS' not in section:
            if access == "ssh" and ".prod." in hostname:
              new_metric.ts_start, new_metric.ts_end = transform_ts(ts_start, ts_end, "UTC")
            #else:
            #  new_metric.ts_start, new_metric.ts_end = transform_ts(ts_start, ts_end, "PDT")
          metrics.append(new_metric)

    # get metric log data, parse and graph
    # TODO: Use Jinja templates
    if outdir_default:
      try:
        os.makedirs(outdir_default)
      except OSError as exeption:
        if exeption.errno != errno.EEXIST:
          raise
      print "Report.html and the plots will be in:", outdir_default
    else:
      sys.exit("No output directory defined. Please use option -o, or update the config. Exiting...")
    Metric.graphing_modules = graphing_modules
    html_string = []
    metric_string_list = []
    if graph_timezone:
      print "X-axis will be displayed in timezone:", graph_timezone
    threads = []
    for metric in metrics:
      thread = threading.Thread(target=parse_and_plot_single_metrics, args=(metric, graph_timezone, outdir_default, indir_default, metric_string_list, graphing_library))
      thread.start()
      threads.append(thread)
    for t in threads:
      t.join()
    cross_plotting_html_string = neelix.metric.nway_plotting(crossplots, metrics, outdir_default, filler)
    html_string.append(cross_plotting_html_string)
    html_string.append("<h1>Single Metrics</h1>\n")
    html_string.extend(metric_string_list)
    neelix.metric.generate_html_report(outdir_default, ''.join(html_string))
    if outdir_default:
      print "Report generated at {0}".format( os.path.join(outdir_default, "Report.html") )

if __name__ == '__main__':
  main()
